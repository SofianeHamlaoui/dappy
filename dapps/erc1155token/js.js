!function(e){var t={};function n(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.l=!0,a.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)n.d(r,a,function(t){return e[t]}.bind(null,a));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=12)}([function(e,t){e.exports=React},function(e,t,n){const{erc1155Term:r}=n(5),{createTokensTerm:a}=n(6),{purchaseTokensTerm:o}=n(7),{sendTokensTerm:i}=n(8),{setLockedTerm:c}=n(9),{updateTokenDataTerm:u}=n(10),{updateBagDataTerm:l}=n(11);e.exports={erc1155Term:r,createTokensTerm:a,purchaseTokensTerm:o,sendTokensTerm:i,setLockedTerm:c,updateTokenDataTerm:u,updateBagDataTerm:l}},function(e,t){e.exports=ReactRedux},function(e,t){e.exports=ReactDOM},function(e,t){e.exports=Redux},function(e,t){e.exports.erc1155Term=(e,t)=>`new \n  mainCh,\n  createCh,\n  purchaseCh,\n  sendCh,\n  entryCh,\n  entryUriCh,\n  setLockedCh,\n  updateTokenDataCh,\n  updateBagDataCh,\n  updateUriCh,\n  bags,\n  bagsData,\n  tokensData,\n  verifySignatureAndUpdateNonceCh,\n  justVerifySignatureCh,\n  insertArbitrary(\`rho:registry:insertArbitrary\`),\n  stdout(\`rho:io:stdout\`),\n  secpVerify(\`rho:crypto:secp256k1Verify\`),\n  blake2b256(\`rho:crypto:blake2b256Hash\`),\n  revAddress(\`rho:rev:address\`),\n  registryLookup(\`rho:registry:lookup\`)\nin {\n\n\n  /*\n    bags: {\n      [bagId: String (incremental id)]: {\n        publicKey: String (public key),\n        n: Nil \\/ String (token id),\n        price: Nil \\/ Int\n        quantity: Int\n      }\n    }\n  */\n  bags!({/*DEFAULT_BAGS*/}) |\n\n  /*\n    bagsData: {\n      [bagId: String (bag id)]: Any\n    }\n  */\n  bagsData!({/*DEFAULT_BAGS_DATA*/}) |\n\n  /*\n    tokensData: {\n      [n: Strig (token id)]: String (registry URI)\n    }\n  */\n  tokensData!({/*DEFAULT_TOKENS_DATA*/}) |\n\n  for (@(payload, returnCh) <= verifySignatureAndUpdateNonceCh) {\n    stdout!("verifySignatureAndUpdateNonceCh") |\n    new hashCh, verifySignatureCh in {\n      match payload {\n        { "newNonce": String, "signature": String} => {\n          for (@current <<- mainCh) {\n            blake2b256!(\n              current.get("nonce").toUtf8Bytes(),\n              *hashCh\n            ) |\n            for (@hash <- hashCh) {\n              secpVerify!(\n                hash,\n                payload.get("signature").hexToBytes(),\n                current.get("publicKey").hexToBytes(),\n                *verifySignatureCh\n              )\n            } |\n            for (@result <- verifySignatureCh) {\n              match result {\n                true => {\n                  @returnCh!(true) |\n                  for (@c <- mainCh) {\n                    mainCh!(c.set("nonce", payload.get("newNonce")))\n                  }\n                }\n                false => {\n                  @returnCh!("error: Invalid signature, could not perform operation")\n                }\n              }\n            }\n          }\n        }\n        _ => {\n          @returnCh!("error: invalid payload, structure should be { 'newNonce': String, 'signature': String }")\n        }\n      }\n    }\n  } |\n\n  for (@(publicKey, signature, nonce, returnCh) <= justVerifySignatureCh) {\n    stdout!("justVerifySignatureCh") |\n    new hashCh, verifySignatureCh in {\n      blake2b256!(\n        nonce.toUtf8Bytes(),\n        *hashCh\n      ) |\n      for (@hash <- hashCh) {\n        secpVerify!(\n          hash,\n          signature.hexToBytes(),\n          publicKey.hexToBytes(),\n          *verifySignatureCh\n        )\n      } |\n      for (@result <- verifySignatureCh) {\n        @returnCh!(result)\n      }\n    }\n  } |\n\n  contract setLockedCh(payload, return) = {\n    stdout!("setLockedCh") |\n\n    for (@current <<- mainCh) {\n      match current.get("locked") {\n        true => {\n          return!("error: contract is already locked")\n        }\n        false => {\n          new verifyCh in {\n            verifySignatureAndUpdateNonceCh!((\n              {\n                "newNonce": *payload.get("newNonce"),\n                "signature": *payload.get("signature"),\n              },\n              *verifyCh\n            )) |\n            for (@verified <- verifyCh) {\n              match verified {\n                true => {\n                  for (@c <- mainCh) {\n                    mainCh!(c.set("locked", true))\n                  } |\n                  return!(true)\n                }\n                err => {\n                  return!(err)\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  contract updateTokenDataCh(payload, return) = {\n    stdout!("updateTokenDataCh") |\n\n    for (@current <<- mainCh) {\n      match current.get("locked") {\n        true => {\n          return!("error: contract is locked, cannot update token data")\n        }\n        false => {\n          new verifyCh in {\n            verifySignatureAndUpdateNonceCh!((\n              {\n                "newNonce": *payload.get("newNonce"),\n                "signature": *payload.get("signature"),\n              },\n              *verifyCh\n            )) |\n            for (@verified <- verifyCh) {\n              match verified {\n                true => {\n                  for (@currentTokensData <- tokensData) {\n                    tokensData!(\n                      currentTokensData.set(*payload.get("n"), *payload.get("data"))\n                    )\n                  } |\n                  return!(true)\n                }\n                err => {\n                  return!(err)\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  contract updateBagDataCh(payload, return) = {\n    stdout!("updateBagDataCh") |\n    for (@currentBags <<- bags) {\n      match currentBags.get(*payload.get("bagId")) {\n        Nil => {\n          return!("error : token (bag ID) " ++ *payload.get("bagId") ++ " does not exist")\n        }\n        bag => {\n          new verifyCh in {\n            justVerifySignatureCh!((\n              bag.get("publicKey"),\n              *payload.get("signature"),\n              bag.get("nonce"),\n              *verifyCh\n            )) |\n            for (@verified <- verifyCh) {\n              match verified {\n                true => {\n                  for (@currentBagsData <- bagsData) {\n                    bagsData!(\n                      currentBagsData.set(*payload.get("bagId"), *payload.get("data"))\n                    ) |\n                    return!(true)\n                  }\n                }\n                err => {\n                  return!("error: Invalid signature, could not perform operation")\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  // add a token (1 or more)\n  contract createCh(payload, return) = {\n    stdout!("createCh") |\n\n    for (@current <<- mainCh) {\n      match current.get("locked") {\n        true => {\n          return!("error: contract is locked, cannot create token")\n        }\n        false => {\n          for (@currentBags <<- bags) {\n            new verifyCh in {\n              verifySignatureAndUpdateNonceCh!((\n                {\n                  "newNonce": *payload.get("newNonce"),\n                  "signature": *payload.get("signature"),\n                },\n                *verifyCh\n              )) |\n              for (@verified <- verifyCh) {\n                match verified {\n                  true => {\n                    match "\${n}" %% { "n": currentBags.size() } {\n                      bagId => {\n                        new nCh in {\n\n                          match *payload.get("n") {\n                            // token n already exists\n                            String => { nCh!(*payload.get("n")) }\n                            // token n does not exist, bag ID will be used as n\n                            _ => { nCh!(bagId) }\n                          } |\n\n                          for (@n <- nCh) {\n                            for (_ <- bags) {\n                              bags!(\n                                currentBags.set(bagId, {\n                                  "quantity": *payload.get("quantity"),\n                                  "publicKey": *payload.get("publicKey"),\n                                  "nonce": *payload.get("bagNonce"),\n                                  "n": n,\n                                  "price": *payload.get("price"),\n                                })\n                              ) \n                            } |\n\n                            match *payload.get("data") {\n                              Nil => {}\n                              data => {\n                                for (@currentTokensData <- tokensData) {\n                                  tokensData!(\n                                    currentTokensData.set(n, data)\n                                  )\n                                }\n                              }\n                            } |\n\n                            return!(true)\n                          }\n                        }\n                      }\n                    }\n                  }\n                  err => {\n                    return!(err)\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  // purchase token (1 or more)\n  contract purchaseCh(payload, return) = {\n    stdout!("purchaseCh") |\n    for (@currentBags <<- bags) {\n      match currentBags.get(*payload.get("bagId")) {\n        Nil => {\n          return!("error : token (bag ID) " ++ *payload.get("bagId") ++ " does not exist")\n        }\n        bag => {\n          match bag.get("quantity") - *payload.get("quantity") >= 0 {\n            false => {\n              return!("error : not enough tokens in bag (bag ID: " ++ *payload.get("bagId") ++ ") available")\n            }\n            true => {\n              new RevVaultCh, ownerRevAddressCh in {\n\n                registryLookup!(\`rho:rchain:revVault\`, *RevVaultCh) |\n                revAddress!("fromPublicKey", bag.get("publicKey").hexToBytes(), *ownerRevAddressCh) |\n\n                for (@(_, RevVault) <- RevVaultCh; @ownerRevAddress <- ownerRevAddressCh) {\n                  match (\n                    *payload.get("purseRevAddr"),\n                    ownerRevAddress,\n                    *payload.get("quantity") * bag.get("price")\n                  ) {\n                    (from, to, amount) => {\n                      new purseVaultCh in {\n                        @RevVault!("findOrCreate", from, *purseVaultCh) |\n                        for (@(true, purseVault) <- purseVaultCh) {\n\n                          new resultCh in {\n                            @purseVault!("transfer", to, amount, *payload.get("purseAuthKey"), *resultCh) |\n                            for (@result <- resultCh) {\n\n                              match result {\n                                (true, Nil) => {\n                                  match "\${bagId}" %% { "bagId": currentBags.size() } {\n                                    bagId => {\n                                      match *payload.get("data") {\n                                        Nil => {}\n                                        data => {\n                                          for (@currentBagsData <- bagsData) {\n                                            bagsData!(currentBagsData.set(bagId, data))\n                                          }\n                                        }\n                                      } |\n                                      for (_ <- bags) {\n                                        bags!(\n                                          // New bag ID for new token ownership\n                                          currentBags.set(bagId, {\n                                            "quantity": *payload.get("quantity"),\n                                            "publicKey": *payload.get("publicKey"),\n                                            "nonce": *payload.get("nonce"),\n                                            "n": bag.get("n"),\n                                            "price": Nil,\n                                          // Udate quantity in seller token ownership\n                                          }).set(\n                                            *payload.get("bagId"),\n                                            bag.set("quantity", bag.get("quantity") - *payload.get("quantity"))\n                                          )\n                                        ) |\n                                        return!(true)\n                                      }\n                                    }\n                                  }\n                                }\n                                _ => {\n                                  bags!(currentBags) |\n                                  return!("error : REV transfer went wrong " ++ result.nth(2))\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  contract sendCh(payload, return) = {\n    stdout!("sendCh") |\n    for (@currentBags <<- bags) {\n      match currentBags.get(*payload.get("bagId")) {\n        Nil => {\n          return!("error : token (bag ID) " ++ *payload.get("bagId") ++ " does not exist")\n        }\n        bag => {\n          match bag.get("quantity") - *payload.get("quantity") >= 0 {\n            true => {\n              new justVerifySignatureReturnCh in {\n                justVerifySignatureCh!((\n                  bag.get("publicKey"),\n                  *payload.get("signature"),\n                  bag.get("nonce"),\n                  *justVerifySignatureCh\n                )) |\n                for (@r <- justVerifySignatureCh) {\n                  stdout!(r) |\n                  match r {\n                    true => {\n                      match "\${bagId}" %% { "bagId": currentBags.size() } {\n                        bagId => {\n                          // Add bag data if found in payload\n                          match *payload.get("data") {\n                            Nil => {}\n                            data => {\n                              for (@currentBagsData <- bagsData) {\n                                bagsData!(currentBagsData.set(bagId, data))\n                              }\n                            }\n                          } |\n                          for (_ <- bags) {\n                            bags!(\n                              // New bag ID for new token ownership\n                              currentBags.set(bagId, {\n                                "quantity": *payload.get("quantity"),\n                                "publicKey": *payload.get("publicKey"),\n                                "nonce": *payload.get("bagNonce"),\n                                "n": bag.get("n"),\n                                "price": Nil,\n                              // Udate quantity in seller token ownership\n                              }).set(\n                                *payload.get("bagId"),\n                                bag.set(\n                                  "quantity", bag.get("quantity") - *payload.get("quantity")\n                                ).set(\n                                  "nonce",\n                                  *payload.get("bagNonce2")\n                                )\n                              )\n                            )\n                          } |\n                          return!(true)\n                        }\n                      }\n                    }\n                    false => {\n                      return!("error: Invalid signature, could not perform operation")\n                    }\n                  }\n                }\n              }\n            }\n            false => {\n              return!("error : not enough tokens in bag (bag ID) " ++ *payload.get("bagId") ++ " available")\n            }\n          }\n        }\n      }\n    }\n  } |\n  \n  contract entryCh(action, return) = {\n    match *action.get("type") {\n      // Read capabilities\n      "READ_BAGS" => {\n        for (currentBags <<- bags) {\n          return!(*currentBags)\n        }\n      }\n      "READ_BAGS_DATA" => {\n        for (currentBagsData <<- bagsData) {\n          return!(*currentBagsData)\n        }\n      }\n      "READ_TOKENS_DATA" => {\n        for (@currentTokensData <<- tokensData) {\n          return!(currentTokensData)\n        }\n      }\n      "READ" => {\n        for (current <<- mainCh) {\n          return!(*current)\n        }\n      }\n      // Admin capabilities (require a signature of the nonce)\n      "SET_LOCKED" => {\n        match *action.get("payload") {\n          { "locked": true, "signature": String, "newNonce": String } => {\n            setLockedCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'signature': String, 'newNonce': String, 'locked': Boolean }")\n          }\n        }\n      }\n      "UPDATE_TOKEN_DATA" => {\n        match *action.get("payload") {\n          { "signature": String, "newNonce": String, "n": String, "data": _ } => {\n            updateTokenDataCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'signature': String, 'newNonce': String, 'n': String, 'data': _ }")\n          }\n        }\n      }\n      "UPDATE_BAG_DATA" => {\n        match *action.get("payload") {\n          { "signature": String, "newNonce": String, "bagId": String, "data": _ } => {\n            updateBagDataCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'signature': String, 'newNonce': String, 'bagId': String, 'data': _ }")\n          }\n        }\n      }\n      "CREATE_TOKENS" => {\n        match *action.get("payload") {\n          {\n            "signature": String,\n            "newNonce": String,\n            "bagNonce": String,\n            "quantity": Int,\n            "publicKey": String,\n            "price": Nil \\/ Int,\n            "n": Nil \\/ String,\n            "data": _\n          } => {\n            createCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'signature': String, 'newNonce': String, 'bagNonce': String, 'quantity': Int, 'n': Nil or String, 'price': Nil or Int, 'publicKey': String, 'data': Any }")\n          }\n        }\n      }\n      // Anyone capabilities\n      "PURCHASE_TOKENS" => {\n        match *action.get("payload") {\n          { "quantity": Int, "bagId": String, "publicKey": String, "nonce": String, "data": _, "purseRevAddr": _, "purseAuthKey": _ } => {\n            purchaseCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'quantity': Int, 'bagId': String, 'publicKey': String, 'nonce': String, 'data': Any, 'purseRevAddr': String, 'purseAuthKey': AuthKey }")\n          }\n        }\n      }\n      "SEND_TOKENS" => {\n        match *action.get("payload") {\n          { "quantity": Int, "bagId": String, "publicKey": String, "signature": String, "bagNonce": String, "bagNonce2": String, "data": _, } => {\n            sendCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'quantity': Int, 'bagId': Int, 'publicKey': String, 'signature': String, 'bagNonce': String, 'bagNonce2': String, 'data': Any }")\n          }\n        }\n      }\n      _ => {\n        return!("error: unknown action")\n      }\n    }\n  } |\n\n  insertArbitrary!(*entryCh, *entryUriCh) |\n\n  for (entryUri <- entryUriCh) {\n\n    mainCh!({\n      "registryUri": *entryUri,\n      "locked": false,\n      "publicKey": "${t}",\n      "nonce": "${e}",\n      "version": "0.3"\n    }) |\n    stdout!({\n      "registryUri": *entryUri,\n      "locked": false,\n      "publicKey": "${t}",\n      "nonce": "${e}",\n      "version": "0.3"\n    })\n\n    /*OUTPUT_CHANNEL*/\n  }\n}\n`},function(e,t){e.exports.createTokensTerm=(e,t,n,r,a,o,i,c,u)=>`new basket,\n  entryCh,\n  returnCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${e}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "CREATE_TOKENS",\n        "payload": {\n          // signature of the current nonce, with the private key of the owner (generateSignatureForNonce.js)\n          "signature": "${t}",\n          // new nonce, must be different and random (generateNonce.js)\n          "newNonce": "${n}",\n          // new nonce for the bag, must be random (generateNonce.js)\n          "bagNonce": "${r}",\n          // per token price, can be Nil if the token is not for sale\n          "price": ${i||"Nil"},\n          // The token you create can be a new one ("n" : Nil)\n          // or it can be linked to an existing token data (ex: "n": "0")\n          "n": ${"string"==typeof o?'"'+o+'"':"Nil"},\n          // quantity of tokens to create\n          "quantity": ${c},\n          // publicKey this set of tokens (depending on quantity) will belong to\n          "publicKey": "${a}", // used only if new token\n          // data is used only if new token ("n" : Nil)\n          "data": ${u?'"'+encodeURI(u)+'"':"Nil"}\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      String => { stdout!(*resp) }\n      true => { stdout!("success, token created") }\n    }\n  } |\n\n  basket!({ "status": "completed" })\n\n}\n`},function(e,t){e.exports.purchaseTokensTerm=(e,t,n,r,a,o,i)=>`\nnew\n  revVaultPurseCh,\n  priceCh,\n  quantityCh,\n  publicKeyCh,\n  nonceCh,\n  bagDataCh,\n  returnCh,\n  bagIdCh,\n  registryUriCh,\n  revAddressCh,\n  registryLookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`),\n  revAddress(\`rho:rev:address\`)\nin {\n\n  /*\n    The 5 following values must be filled with proper values\n  */ \n  // Registry URI of the ERC-1155 contract\n  registryUriCh!!(\`rho:id:${e}\`) |\n  // Unique ID of the token you want to purchase\n  bagIdCh!!("${t}") |\n  // Per token price, make sure it is accurate\n  priceCh!!(${n||"Nil"}) |\n  // Bag data: Any\n  bagDataCh!!(${r?'"'+encodeURI(r)+'"':"Nil"}) |\n  // Quantity you want to purchase, make sure enough are available\n  quantityCh!!(${a}) |\n  // Your public key\n  publicKeyCh!!("${o}") |\n  // A unique nonce to be changed on each operation\n  nonceCh!!("${i}") |\n\n  registryLookup!(\`rho:rchain:revVault\`, *revVaultPurseCh) |\n\n  /*\n    Create a vault/purse that is just used once (purse)\n  */\n  for(@(_, *RevVaultPurse) <- revVaultPurseCh) {\n    new unf, purseRevAddrCh, purseAuthKeyCh, vaultCh, revAddressCh in {\n      revAddress!("fromUnforgeable", *unf, *purseRevAddrCh) |\n      RevVaultPurse!("unforgeableAuthKey", *unf, *purseAuthKeyCh) |\n      for (@purseAuthKey <- purseAuthKeyCh; @purseRevAddr <- purseRevAddrCh) {\n\n        stdout!({"new purse rev addr": purseRevAddr, "purse authKey": purseAuthKey}) |\n\n        RevVaultPurse!("findOrCreate", purseRevAddr, *vaultCh) |\n\n        for (\n          @(true, *vault) <- vaultCh;\n          @publicKey <- publicKeyCh;\n          @nonce <- nonceCh;\n          @bagId <- bagIdCh;\n          @registryUri <- registryUriCh;\n          @price <- priceCh;\n          @bagData <- bagDataCh;\n          @quantity <- quantityCh\n        ) {\n\n          revAddress!("fromPublicKey", publicKey.hexToBytes(), *revAddressCh) |\n\n          new RevVaultCh in {\n\n            registryLookup!(\`rho:rchain:revVault\`, *RevVaultCh) |\n            for (@(_, RevVault) <- RevVaultCh; deployerRevAddress <- revAddressCh) {\n\n              stdout!(("3.transfer_funds.rho")) |\n\n              /*\n                Put price * quantity REV in the purse\n              */\n              match (\n                *deployerRevAddress,\n                purseRevAddr,\n                price * quantity\n              ) {\n                (from, to, amount) => {\n\n                  new vaultCh, revVaultkeyCh, deployerId(\`rho:rchain:deployerId\`) in {\n                    @RevVault!("findOrCreate", from, *vaultCh) |\n                    @RevVault!("deployerAuthKey", *deployerId, *revVaultkeyCh) |\n                    for (@(true, vault) <- vaultCh; key <- revVaultkeyCh) {\n\n                      stdout!(("Beginning transfer of ", amount, "REV from", from, "to", to)) |\n\n                      new resultCh, entryCh in {\n                        @vault!("transfer", to, amount, *key, *resultCh) |\n                        for (@result <- resultCh) {\n\n                          stdout!(("Finished transfer of ", amount, "REV to", to, "result was:", result)) |\n                          match result {\n                            (true, Nil) => {\n                              stdout!("yes") |\n                              registryLookup!(registryUri, *entryCh) |\n\n                              for(entry <- entryCh) {\n                                stdout!(("GET ENTRY", *entry)) |\n                                entry!(\n                                  {\n                                    "type": "PURCHASE_TOKENS",\n                                    "payload": {\n                                      "quantity": quantity,\n                                      "bagId": bagId,\n                                      "data": bagData,\n                                      "nonce": nonce,\n                                      "publicKey": publicKey,\n                                      "purseRevAddr": purseRevAddr,\n                                      "purseAuthKey": purseAuthKey\n                                    }\n                                  },\n                                  *returnCh\n                                ) |\n                                for (resp <- returnCh) {\n                                  match *resp {\n                                    String => { stdout!(*resp) }\n                                    true => { stdout!("success, purchase successful") }\n                                  }\n                                }\n                              }\n                            }\n                            _ => {\n                              stdout!(result) |\n                              stdout!("no")\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n`},function(e,t){e.exports.sendTokensTerm=(e,t,n,r,a,o,i,c)=>`new basket,\n  entryCh,\n  returnCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${e}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "SEND_TOKENS",\n        "payload": {\n          // signature of the current nonce, with the private key of the owner (generateSignatureForNonce.js)\n          "signature": "${t}",\n          // new nonce, must be different and random (generateNonce.js)\n          "bagNonce": "${n}",\n          // new nonce for the new bag\n          "bagNonce2": "${r}",\n          // bag ID (ex: "0")\n          "bagId": "${i}",\n          // quantity of tokens to send\n          "quantity": ${a},\n          // publicKey this send those tokens to (can be the same just split a bag)\n          "publicKey": "${o}",\n          // data (optional) to be attached to the new bag (in bagsData)\n          "data": ${c?'"'+encodeURI(c)+'"':"Nil"}\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      String => { stdout!(*resp) }\n      true => { stdout!("success, tokens sent") }\n    }\n  } |\n\n  basket!({ "status": "completed" })\n\n}\n`},function(e,t){e.exports.setLockedTerm=(e,t,n)=>`new basket,\n  entryCh,\n  returnCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${e}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "SET_LOCKED",\n        "payload": {\n          // signature of the current nonce, with the private key of the owner (generateSignatureForNonce.js)\n          "signature": "${n}",\n          // new nonce, must be different and random (generateNonce.js)\n          "newNonce": "${t}",\n          //you cannot unlock, this value must always be true\n          "locked": true\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      String => { stdout!(*resp) }\n      true => { stdout!("success, tokens locked") }\n    }\n  } |\n\n  basket!({ "status": "completed" })\n\n}\n`},function(e,t){e.exports.updateTokenDataTerm=(e,t,n,r)=>`new basket,\n  entryCh,\n  returnCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${e}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "UPDATE_TOKEN_DATA",\n        "payload": {\n          // signature of the current nonce, with the private key of the owner (generateSignatureForNonce.js)\n          "signature": "${signature}",\n          // new nonce, must be different and random (generateNonce.js)\n          "newNonce": "${t}",\n          // token ID you want to attach data to\n          "n": ${"string"==typeof n?'"'+n+'"':"Nil"},\n          // data is used only if new token ("n" : Nil)\n          "data": ${r?'"'+encodeURI(r)+'"':"Nil"}\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      String => { stdout!(*resp) }\n      true => { stdout!("success, token data updated") }\n    }\n  } |\n\n  basket!({ "status": "completed" })\n\n}\n`},function(e,t){e.exports.updateBagDataTerm=(e,t,n,r,a)=>`new basket,\n  entryCh,\n  returnCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${e}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "UPDATE_BAG_DATA",\n        "payload": {\n          // signature of the current nonce, with the private key of the owner (generateSignatureForNonce.js)\n          "signature": "${n}",\n          // new nonce, must be different and random (generateNonce.js)\n          "newNonce": "${t}",\n          // bag ID you want to attach data to\n          "bagId": "${r}",\n          // data is used only if new token ("n" : Nil)\n          "data": ${a?'"'+encodeURI(a)+'"':"Nil"}\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      String => { stdout!(*resp) }\n      true => { stdout!("success, bag data updated") }\n    }\n  } |\n\n  basket!({ "status": "completed" })\n\n}\n`},function(e,t,n){"use strict";n.r(t);var r=n(0),a=n.n(r),o=n(3),i=n.n(o),c=n(2),u=n(4);function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){p(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var f={registryUri:void 0,publicKey:void 0,nonce:void 0,tokensData:void 0,bags:void 0,bagsData:void 0,tab:void 0,loading:!1},d=Object(u.createStore)((function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:f,t=arguments.length>1?arguments[1]:void 0;switch(console.log(t),t.type){case"INIT":return s(s({},e),{},{registryUri:t.payload.registryUri});case"SET_LOADING":return s(s({},e),{},{loading:t.payload});case"INIT_TOKEN":return s(s({},e),{},{publicKey:t.payload.publicKey,locked:t.payload.locked,nonce:t.payload.nonce,tokensData:t.payload.tokensData,bags:t.payload.bags,bagsData:t.payload.bagsData,loading:!1});case"UPDATE_NONCE":return s(s({},e),{},{nonce:t.payload});case"CHANGE_TAB":return s(s({},e),{},{tab:t.payload});case"IDENTIFIED":return s(s({},e),{},{identified:!0});case"UPDATE_NONCE":return s(s({},e),{},{nonce:t.payload});default:return e}})),y=n(1);function g(e){return(g="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function b(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function h(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function m(e,t){return(m=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function v(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,r=E(e);if(t){var a=E(this).constructor;n=Reflect.construct(r,arguments,a)}else n=r.apply(this,arguments);return k(this,n)}}function k(e,t){return!t||"object"!==g(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function E(e){return(E=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var C=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&m(e,t)}(i,e);var t,n,r,o=v(i);function i(){return b(this,i),o.apply(this,arguments)}return t=i,(n=[{key:"render",value:function(){var e=this;return!this.registryUri&&this.props.registryUri&&(this.registryUri=this.props.registryUri),a.a.createElement("div",{className:"form horizontal form-horizontal"},a.a.createElement("div",{className:"field"},a.a.createElement("div",{className:"control"},a.a.createElement("input",{onChange:function(t){return e.registryUri=t.target.value},className:"input registry-uri-input",type:"text",placeholder:"Registry URI",defaultValue:this.props.registryUri}),this.props.loading?a.a.createElement("button",{disabled:!0,type:"button",className:"button is-light"},"Loading"):a.a.createElement("button",{onClick:function(){e.props.loadToken({registryUri:e.registryUri})},type:"button",className:"button is-light"},this.props.registryUri?"Reload":"Load"))))}}])&&h(t.prototype,n),r&&h(t,r),i}(a.a.Component);function N(e){return(N="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function w(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function S(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function D(e,t){return(D=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function T(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,r=R(e);if(t){var a=R(this).constructor;n=Reflect.construct(r,arguments,a)}else n=r.apply(this,arguments);return O(this,n)}}function O(e,t){return!t||"object"!==N(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function R(e){return(R=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var _=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&D(e,t)}(c,e);var t,n,o,i=T(c);function c(){return w(this,c),i.apply(this,arguments)}return t=c,(n=[{key:"render",value:function(){var e=this;return a.a.createElement("div",null,!0===this.props.locked?a.a.createElement(r.Fragment,null,a.a.createElement("h4",{className:"title is-5 locked-t"},"This contract is"," ",a.a.createElement("span",{className:"tag is-success is-medium"},"locked")),a.a.createElement("p",{className:"locked-p"},"The owner cannot add tokens or change existing tokens data anymore.",a.a.createElement("br",null),a.a.createElement("br",null))):void 0,!1===this.props.locked?a.a.createElement(r.Fragment,null,a.a.createElement("h4",{className:"title is-5 locked-t"},"This contract is"," ",a.a.createElement("span",{className:"tag is-danger is-medium"},"not locked")),a.a.createElement("p",{className:"locked-p"},"The owner ",a.a.createElement("b",null,this.props.publicKey)," can still add tokens, and change existing tokens data.",a.a.createElement("br",null),a.a.createElement("br",null))):void 0,a.a.createElement("b",null,"Tokens data"),a.a.createElement("div",{className:"tokens-data"},Object.keys(this.props.tokensData).map((function(t){return a.a.createElement(r.Fragment,{key:t},a.a.createElement("span",null,t," (token ID):"," ",e.props.tokensData[t].length>200?"".concat(e.props.tokensData[t].substr(0,200),"..."):e.props.tokensData[t]),a.a.createElement("hr",null))}))),a.a.createElement("b",null,"Token ownerships / bags"),a.a.createElement("div",{className:"bags"},Object.keys(this.props.bags).map((function(t){return a.a.createElement(r.Fragment,{key:t},a.a.createElement("div",{className:"bag"},a.a.createElement("span",null,"token ID : ",e.props.bags[t].n),a.a.createElement("span",null,"bag ID : ",t),a.a.createElement("span",null,"quantity : ",e.props.bags[t].quantity),a.a.createElement("span",null,"public key : ",e.props.bags[t].publicKey),a.a.createElement("span",null,"price (per token) : ",e.props.bags[t].price)),a.a.createElement("hr",null))}))))}}])&&S(t.prototype,n),o&&S(t,o),c}(a.a.Component);function I(e){return(I="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function A(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function j(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function U(e,t){return(U=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function P(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,r=K(e);if(t){var a=K(this).constructor;n=Reflect.construct(r,arguments,a)}else n=r.apply(this,arguments);return x(this,n)}}function x(e,t){return!t||"object"!==I(t)&&"function"!=typeof t?B(e):t}function B(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function K(e){return(K=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function q(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var V=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&U(e,t)}(i,e);var t,n,r,o=P(i);function i(){var e;A(this,i);for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return q(B(e=o.call.apply(o,[this].concat(n))),"state",{bagId:void 0,quantity:0,data:""}),e}return t=i,(n=[{key:"render",value:function(){var e=this;return a.a.createElement("div",null,a.a.createElement("h4",{className:"title is-4"},"Purchase token(s)"),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Token ownership / bag to buy from"),a.a.createElement("div",{className:"control"},a.a.createElement("div",{class:"select"},a.a.createElement("select",{onChange:function(t){"Select a bag"===t.target.value?e.setState({bagId:void 0}):e.setState({bagId:t.target.value})}},a.a.createElement("option",{value:void 0},"Select a bag"),Object.keys(this.props.bags).filter((function(t){return"number"==typeof e.props.bags[t].price})).map((function(t){return a.a.createElement("option",{disabled:0===e.props.bags[t],key:t,value:t},t)})))))),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Quantity","string"==typeof this.state.bagId?"(available: ".concat(this.props.bags[this.state.bagId].quantity,")"):""),a.a.createElement("div",{className:"control"},a.a.createElement("input",{className:"input",onChange:function(t){return e.setState({quantity:parseInt(t.target.value)})},type:"number",placeholder:"1",step:1,min:0}))),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Data (token data)"),a.a.createElement("div",{className:"control"},a.a.createElement("textarea",{className:"textarea",onChange:function(t){e.setState({data:t.target.value})},defaultValue:""}))),"string"==typeof this.state.bagId?a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Price (total)"," ",this.props.bags[this.state.bagId].price*this.state.quantity)):void 0,a.a.createElement("div",{className:"field"},a.a.createElement("button",{disabled:"string"!=typeof this.state.bagId||!this.state.quantity,className:"button is-light",type:"button",onClick:function(t){e.props.purchaseToken({registryUri:e.props.registryUri,bagId:e.state.bagId,data:e.state.data,price:e.props.bags[e.state.bagId].price,quantity:e.state.quantity})}},"Purchase token(s)")))}}])&&j(t.prototype,n),r&&j(t,r),i}(a.a.Component);function $(e){return($="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function L(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function G(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function F(e,t){return(F=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function H(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,r=M(e);if(t){var a=M(this).constructor;n=Reflect.construct(r,arguments,a)}else n=r.apply(this,arguments);return z(this,n)}}function z(e,t){return!t||"object"!==$(t)&&"function"!=typeof t?J(e):t}function J(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function M(e){return(M=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function Y(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var Q=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&F(e,t)}(i,e);var t,n,r,o=H(i);function i(){var e;L(this,i);for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return Y(J(e=o.call.apply(o,[this].concat(n))),"state",{n:0}),Y(J(e),"reload",(function(t){t.preventDefault(),e.setState({n:e.state.n+1})})),e}return t=i,(n=[{key:"render",value:function(){if("undefined"==typeof dappyStore)return console.warn("window.dappyStore is undefined, cannot lock contract"),a.a.createElement("div",null);var e=dappyStore.getState().transactions;return a.a.createElement("div",null,a.a.createElement("h4",{className:"title is-4"},"Transactions"," ",a.a.createElement("button",{className:"button is-light is-small",onClick:this.reload},"Reload")),a.a.createElement("p",null,"If you deployed a new ERC-1155 contract, reload this section until see the registry URI displayed."),a.a.createElement("br",null),a.a.createElement("ul",null,Object.keys(e).map((function(t){var n;return console.log(e[t]),"string"==typeof e[t].value?n=e[t].value:e[t].value.registryUri?n="registry URI : ".concat(e[t].value.registryUri.replace("rho:id:","")):e[t].value.status&&(n="status : ".concat(e[t].value.status)),a.a.createElement("li",{key:t},t,": ",n)}))))}}])&&G(t.prototype,n),r&&G(t,r),i}(a.a.Component);function W(e){return(W="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function X(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function Z(e,t){return(Z=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function ee(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,r=ne(e);if(t){var a=ne(this).constructor;n=Reflect.construct(r,arguments,a)}else n=r.apply(this,arguments);return te(this,n)}}function te(e,t){return!t||"object"!==W(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function ne(e){return(ne=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var re=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&Z(e,t)}(i,e);var t,n,r,o=ee(i);function i(e){var t;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,i),(t=o.call(this,e)).textarea=a.a.createRef(),t.state={token:void 0,data:'{ "name": "pizza regina" }'},t}return t=i,(n=[{key:"render",value:function(){var e=this;return a.a.createElement("div",null,a.a.createElement("h4",{className:"title is-4"},"Update token data"),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Token to update"),a.a.createElement("div",{className:"control"},a.a.createElement("div",{class:"select"},a.a.createElement("select",{onChange:function(t){"Select a token"===t.target.value?(e.textarea.current.value="",e.setState({token:void 0})):(console.log(e.textarea.current),e.textarea.current.value=e.props.tokensData[t.target.value],e.setState({token:t.target.value,data:e.props.tokensData[t.target.value]}))}},a.a.createElement("option",{value:void 0},"Select a token"),Object.keys(this.props.tokensData).map((function(t){return a.a.createElement("option",{disabled:0===e.props.tokensData[t],key:t,value:t},t)})))))),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Data"),a.a.createElement("p",{className:"note"},a.a.createElement("b",null,"Note: "),"Data will be stored as a string, and secured with"," ",a.a.createElement("b",null,"encodeURI()")),a.a.createElement("div",{className:"control"},a.a.createElement("textarea",{className:"textarea",ref:this.textarea,onChange:function(t){e.setState({data:t.target.value})},defaultValue:'{ "name": "pizza regina" }'}))),a.a.createElement("div",{className:"field"},a.a.createElement("button",{className:"button is-light",type:"button",disabled:"string"!=typeof this.state.token,onClick:function(t){e.props.updateTokenData({registryUri:e.props.registryUri,nonce:e.props.nonce,n:e.state.token,data:e.state.data})}},"Update data")))}}])&&X(t.prototype,n),r&&X(t,r),i}(a.a.Component);function ae(e){return(ae="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function oe(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function ie(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function ce(e,t){return(ce=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function ue(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,r=pe(e);if(t){var a=pe(this).constructor;n=Reflect.construct(r,arguments,a)}else n=r.apply(this,arguments);return le(this,n)}}function le(e,t){return!t||"object"!==ae(t)&&"function"!=typeof t?se(e):t}function se(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function pe(e){return(pe=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function fe(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var de=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&ce(e,t)}(i,e);var t,n,r,o=ue(i);function i(){var e;oe(this,i);for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return fe(se(e=o.call.apply(o,[this].concat(n))),"state",{price:1,quantity:0,data:'{ "name": "pizza regina" }'}),e}return t=i,(n=[{key:"render",value:function(){var e=this;return console.log(this.state),a.a.createElement("div",null,a.a.createElement("h4",{className:"title is-4"},"Create token(s)"),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Data (token data)"),a.a.createElement("div",{className:"control"},a.a.createElement("textarea",{className:"textarea",onChange:function(t){e.setState({data:t.target.value})},defaultValue:'{ "name": "pizza regina" }'}))),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Price (dusts)"),a.a.createElement("div",{className:"control"},a.a.createElement("input",{className:"input",onChange:function(t){return e.setState({price:parseInt(t.target.value)})},type:"number",placeholder:"1",step:1,min:1,defaultValue:1}))),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Quantity"),a.a.createElement("div",{className:"control"},a.a.createElement("input",{className:"input",onChange:function(t){return e.setState({quantity:parseInt(t.target.value)})},type:"number",placeholder:"1",step:1,min:0,defaultValue:1}))),"number"==typeof this.state.quantity&&"number"==typeof this.state.price?a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Bag total value (dusts) ",this.state.price*this.state.quantity)):void 0,a.a.createElement("div",{className:"field"},a.a.createElement("button",{className:"button is-light",type:"button",onClick:function(t){e.props.createToken({registryUri:e.props.registryUri,nonce:e.props.nonce,n:null,data:e.state.data||null,price:e.state.price,quantity:e.state.quantity})}},"Create token(s)")))}}])&&ie(t.prototype,n),r&&ie(t,r),i}(a.a.Component);function ye(e){return(ye="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function ge(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function be(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function he(e,t){return(he=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function me(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,r=ke(e);if(t){var a=ke(this).constructor;n=Reflect.construct(r,arguments,a)}else n=r.apply(this,arguments);return ve(this,n)}}function ve(e,t){return!t||"object"!==ye(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function ke(e){return(ke=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var Ee=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&he(e,t)}(i,e);var t,n,r,o=me(i);function i(){return ge(this,i),o.apply(this,arguments)}return t=i,(n=[{key:"render",value:function(){var e=this;return a.a.createElement("div",null,a.a.createElement("h4",{className:"title is-4"},"Lock contract"),a.a.createElement("article",{className:"message is-danger"},a.a.createElement("div",{className:"message-body"},"If you lock the contract, the tokens currently existing will be the only ones to ever exist for this contract. The only available operations available will be :",a.a.createElement("ul",null,a.a.createElement("li",null,"- Send tokens (as the owner of a bag)."),a.a.createElement("li",null,"- Defining a price for tokens in a bag (as the owner of a bag)."),a.a.createElement("li",null,"- Update data associated to a bag (as the owner of a bag)."),a.a.createElement("li",null,"- Buy a set of tokens from a bag.")))),a.a.createElement("div",{className:"field"},a.a.createElement("button",{className:"button is-danger",type:"button",onClick:function(t){e.props.setLocked({registryUri:e.props.registryUri,nonce:e.props.nonce})}},"Lock contract")))}}])&&be(t.prototype,n),r&&be(t,r),i}(a.a.Component);function Ce(e){return(Ce="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Ne(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function we(e,t){return(we=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function Se(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,r=Te(e);if(t){var a=Te(this).constructor;n=Reflect.construct(r,arguments,a)}else n=r.apply(this,arguments);return De(this,n)}}function De(e,t){return!t||"object"!==Ce(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function Te(e){return(Te=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var Oe=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&we(e,t)}(i,e);var t,n,r,o=Se(i);function i(e){var t;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,i),(t=o.call(this,e)).state={bagId:void 0,publicKey:""},t}return t=i,(n=[{key:"render",value:function(){var e=this;return a.a.createElement("div",null,a.a.createElement("h4",{className:"title is-4"},"Send token(s)"),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"From (bag you own)"),a.a.createElement("div",{className:"control"},a.a.createElement("div",{class:"select"},a.a.createElement("select",{onChange:function(t){"Select a bag"===t.target.value?e.setState({bagId:void 0}):e.setState({bagId:t.target.value})}},a.a.createElement("option",{value:void 0},"Select a bag"),Object.keys(this.props.bags).map((function(t){return a.a.createElement("option",{disabled:0===e.props.bags[t],key:t,value:t},t)})))))),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"To (public key)"),a.a.createElement("div",{className:"control"},a.a.createElement("input",{className:"input",type:"text",onInput:function(t){e.setState({publicKey:t.target.value})}}))),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Amount / Quantity of tokens to send"),this.state.bagId?a.a.createElement("p",{className:"text-warning"},"The selected bag contains"," ",this.props.bags[this.state.bagId].quantity," token(s)"):void 0,a.a.createElement("div",{className:"control"},a.a.createElement("input",{type:"number",className:"input",min:0,onInput:function(t){e.setState({quantity:parseInt(t.target.value)})}}))),a.a.createElement("div",{className:"field"},a.a.createElement("button",{className:"button is-light",type:"button",disabled:"string"!=typeof this.state.bagId||"number"!=typeof this.state.quantity,onClick:function(t){e.props.sendTokens({registryUri:e.props.registryUri,publicKey:e.state.publicKey,nonce:e.props.bags[e.state.bagId].nonce,bagId:e.state.bagId,quantity:e.state.quantity})}},"Send token(s)")))}}])&&Ne(t.prototype,n),r&&Ne(t,r),i}(a.a.Component);function Re(e){return(Re="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function _e(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function Ie(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function Ae(e,t){return(Ae=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function je(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,r=Pe(e);if(t){var a=Pe(this).constructor;n=Reflect.construct(r,arguments,a)}else n=r.apply(this,arguments);return Ue(this,n)}}function Ue(e,t){return!t||"object"!==Re(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function Pe(e){return(Pe=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var xe=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&Ae(e,t)}(i,e);var t,n,r,o=je(i);function i(){return _e(this,i),o.apply(this,arguments)}return t=i,(n=[{key:"render",value:function(){var e=this;return a.a.createElement("div",null,a.a.createElement("h4",{className:"title is-4"},"Deploy new ERC-1155 contract"),a.a.createElement("p",null,"After deployment, go in the ",a.a.createElement("u",null,"Transactions")," section and wait for the registry URI to pop.",a.a.createElement("br",null),a.a.createElement("br",null)),a.a.createElement("div",{className:"field"},a.a.createElement("button",{className:"button is-medium is-primary",type:"button",onClick:function(t){e.props.deploy()}},"Deploy")))}}])&&Ie(t.prototype,n),r&&Ie(t,r),i}(a.a.Component);function Be(e){return(Be="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Ke(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function qe(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function Ve(e,t){return(Ve=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function $e(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,r=Ge(e);if(t){var a=Ge(this).constructor;n=Reflect.construct(r,arguments,a)}else n=r.apply(this,arguments);return Le(this,n)}}function Le(e,t){return!t||"object"!==Be(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function Ge(e){return(Ge=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var Fe=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&Ve(e,t)}(c,e);var t,n,o,i=$e(c);function c(){return Ke(this,c),i.apply(this,arguments)}return t=c,(n=[{key:"render",value:function(){var e=this;return a.a.createElement("div",null,a.a.createElement("b",null,"Bags data"),a.a.createElement("div",{className:"tokens-data"},Object.keys(this.props.bagsData).map((function(t){return a.a.createElement(r.Fragment,{key:t},a.a.createElement("span",null,t," (bag ID) :"," ",e.props.bagsData[t].length>200?"".concat(e.props.bagsData[t].substr(0,200),"..."):e.props.bagsData[t]),a.a.createElement("hr",null))}))))}}])&&qe(t.prototype,n),o&&qe(t,o),c}(a.a.Component);function He(e){return(He="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function ze(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function Je(e,t){return(Je=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function Me(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,r=Qe(e);if(t){var a=Qe(this).constructor;n=Reflect.construct(r,arguments,a)}else n=r.apply(this,arguments);return Ye(this,n)}}function Ye(e,t){return!t||"object"!==He(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function Qe(e){return(Qe=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var We=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&Je(e,t)}(i,e);var t,n,r,o=Me(i);function i(e){var t;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,i),(t=o.call(this,e)).textarea=a.a.createRef(),t.state={bagId:void 0,data:'{ "color": "blue" }'},t}return t=i,(n=[{key:"render",value:function(){var e=this;return a.a.createElement("div",null,a.a.createElement("h4",{className:"title is-4"},"Update bag data"),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Token ownership / bag to update"),a.a.createElement("div",{className:"control"},a.a.createElement("div",{class:"select"},a.a.createElement("select",{onChange:function(t){"Select a bag"===t.target.value?(e.textarea.current.value="",e.setState({bagId:void 0})):(e.props.bagsData[t.target.value]?e.textarea.current.value=e.props.bagsData[t.target.value]:e.textarea.current.value="",e.setState({bagId:t.target.value,data:e.props.bagsData[t.target.value]||""}))}},a.a.createElement("option",{value:void 0},"Select a bag"),Object.keys(this.props.bags).map((function(t){return a.a.createElement("option",{disabled:0===e.props.bagsData[t],key:t,value:t},t)})))))),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Data"),a.a.createElement("p",{className:"note"},a.a.createElement("b",null,"Note: "),"Data will be stored as a string, and secured with"," ",a.a.createElement("b",null,"encodeURI()")),a.a.createElement("div",{className:"control"},a.a.createElement("textarea",{className:"textarea",ref:this.textarea,onInput:function(t){e.setState({data:t.target.value})},defaultValue:'{ "color": "blue" }'}))),a.a.createElement("div",{className:"field"},a.a.createElement("button",{className:"button is-light",type:"button",disabled:"string"!=typeof this.state.bagId,onClick:function(t){e.props.updateBagData({registryUri:e.props.registryUri,nonce:e.props.bags[e.state.bagId].nonce,bagId:e.state.bagId,data:e.state.data})}},"Update data")))}}])&&ze(t.prototype,n),r&&ze(t,r),i}(a.a.Component);function Xe(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if("undefined"==typeof Symbol||!(Symbol.iterator in Object(e)))return;var n=[],r=!0,a=!1,o=void 0;try{for(var i,c=e[Symbol.iterator]();!(r=(i=c.next()).done)&&(n.push(i.value),!t||n.length!==t);r=!0);}catch(e){a=!0,o=e}finally{try{r||null==c.return||c.return()}finally{if(a)throw o}}return n}(e,t)||function(e,t){if(!e)return;if("string"==typeof e)return Ze(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return Ze(e,t)}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Ze(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}var et=Object(c.connect)((function(e){return{loading:e.loading,tokensData:e.tokensData,bags:e.bags,bagsData:e.bagsData,tab:e.tab,registryUri:e.registryUri,nonce:e.nonce,publicKey:e.publicKey,locked:e.locked}}),(function(e){return{goCreateToken:function(){e({type:"CHANGE_TAB",payload:"creatingToken"})},goUpdateTokenData:function(){e({type:"CHANGE_TAB",payload:"updatingTokenData"})},goUpdateBagData:function(){e({type:"CHANGE_TAB",payload:"updatingBagData"})},goSeeBagsData:function(){e({type:"CHANGE_TAB",payload:"seeingBagsData"})},goPurchase:function(){e({type:"CHANGE_TAB",payload:"purchasing"})},goDashboard:function(){e({type:"CHANGE_TAB",payload:void 0})},goDeploy:function(){e({type:"CHANGE_TAB",payload:"deploying"})},goSend:function(){e({type:"CHANGE_TAB",payload:"sending"})},goTransactions:function(){e({type:"CHANGE_TAB",payload:"transactions"})},goSetLocked:function(){e({type:"CHANGE_TAB",payload:"locking"})},setLocked:function(t){console.log(t);var n=blockchainUtils.generateNonce();"undefined"!=typeof dappyRChain?dappyRChain.transaction({term:Object(y.setLockedTerm)(t.registryUri,n,"SIGN"),signatures:{SIGN:t.nonce}}).then((function(t){console.log(t),e({type:"UPDATE_NONCE",payload:n})})):console.warn("window.dappyRChain is undefined, cannot lock contract")},updateTokenData:function(t){console.log(t);var n=blockchainUtils.generateNonce();"undefined"!=typeof dappyRChain?dappyRChain.transaction({term:Object(y.updateTokenDataTerm)(t.registryUri,n,t.n,t.data),signatures:{SIGN:t.nonce}}).then((function(t){console.log(t),e({type:"UPDATE_NONCE",payload:n})})):console.warn("window.dappyRChain is undefined, cannot create token")},updateBagData:function(e){console.log(e);var t=blockchainUtils.generateNonce();"undefined"!=typeof dappyRChain?dappyRChain.transaction({term:Object(y.updateBagDataTerm)(e.registryUri,t,"SIGN",e.bagId,e.data),signatures:{SIGN:e.nonce}}).then((function(e){console.log(e)})):console.warn("window.dappyRChain is undefined, cannot create token")},sendTokens:function(e){console.log(e);var t=blockchainUtils.generateNonce(),n=blockchainUtils.generateNonce();"undefined"!=typeof dappyRChain?dappyRChain.transaction({term:Object(y.sendTokensTerm)(e.registryUri,"SIGN",t,n,e.quantity,e.publicKey,e.bagId,void 0),signatures:{SIGN:e.nonce}}).then((function(e){console.log(e)})):console.warn("window.dappyRChain is undefined, cannot create token")},createToken:function(t){console.log(t);var n=blockchainUtils.generateNonce(),r=blockchainUtils.generateNonce();"undefined"!=typeof dappyRChain?dappyRChain.transaction({term:Object(y.createTokensTerm)(t.registryUri,"SIGN",n,r,"PUBLIC"+"_KEY".substr(0),t.n,t.price,t.quantity,t.data),signatures:{SIGN:t.nonce}}).then((function(t){console.log(t),e({type:"UPDATE_NONCE",payload:n})})):console.warn("window.dappyRChain is undefined, cannot create token")},purchaseToken:function(e){console.log(e);var t=blockchainUtils.generateNonce();"undefined"!=typeof dappyRChain?dappyRChain.transaction({term:Object(y.purchaseTokensTerm)(e.registryUri,e.bagId,e.price,e.data,e.quantity,"PUBLIC_"+"KEY".substr(0),t),signatures:{}}).then((function(e){console.log(e)})):console.warn("window.dappyRChain is undefined, cannot purchase token")},loadToken:function(t){var n;(console.log(t),"undefined"!=typeof dappyRChain)?(e({type:"SET_LOADING",payload:!0}),(n=t.registryUri,new Promise((function(e,t){dappyRChain.exploreDeploys("dappy://explore-deploys",["new return, entryCh, readCh, lookup(`rho:registry:lookup`) in {\n            lookup!(`rho:id:".concat(n,'`, *entryCh) |\n            for(entry <- entryCh) {\n              new x in {\n                entry!({ "type": "READ" }, *x) |\n                for (y <- x) {\n                  return!(*y)\n                }\n              }\n            }\n          }'),"new return, entryCh, readCh, lookup(`rho:registry:lookup`) in {\n            lookup!(`rho:id:".concat(n,'`, *entryCh) |\n            for(entry <- entryCh) {\n              new x in {\n                entry!({ "type": "READ_TOKENS_DATA" }, *x) |\n                for (y <- x) {\n                  return!(*y)\n                }\n              }\n            }\n          }'),"new return, entryCh, readCh, lookup(`rho:registry:lookup`) in {\n            lookup!(`rho:id:".concat(n,'`, *entryCh) |\n            for(entry <- entryCh) {\n              new x in {\n                entry!({ "type": "READ_BAGS" }, *x) |\n                for (y <- x) {\n                  return!(*y)\n                }\n              }\n            }\n          }'),"new return, entryCh, readCh, lookup(`rho:registry:lookup`) in {\n            lookup!(`rho:id:".concat(n,'`, *entryCh) |\n            for(entry <- entryCh) {\n              new x in {\n                entry!({ "type": "READ_BAGS_DATA" }, *x) |\n                for (y <- x) {\n                  return!(*y)\n                }\n              }\n            }\n          }')]).then((function(t){var n=JSON.parse(t).results,r=blockchainUtils.rhoValToJs(JSON.parse(n[0].data).expr[0]),a=r.nonce,o=r.locked,i=r.publicKey,c=blockchainUtils.rhoValToJs(JSON.parse(n[1].data).expr[0]),u={};Object.keys(c).forEach((function(e){u[e]=decodeURI(c[e])}));var l=blockchainUtils.rhoValToJs(JSON.parse(n[2].data).expr[0]),s=blockchainUtils.rhoValToJs(JSON.parse(n[3].data).expr[0]),p={};Object.keys(s).forEach((function(e){p[e]=decodeURI(s[e])})),e({publicKey:i,nonce:a,locked:o,tokensData:u,bags:l,bagsData:p})})).catch((function(e){t(e)}))}))).then((function(t){e({type:"INIT_TOKEN",payload:t})})).catch((function(e){console.error("Something went wrong when loading data"),console.log(e)}))):console.warn("window.dappyRChain is undefined, cannot fetch data")},deploy:function(){var t=blockchainUtils.generateNonce();"undefined"!=typeof dappyRChain?dappyRChain.transaction({term:Object(y.erc1155Term)(t,"PUBLIC"+"_KEY".substr(0)),signatures:{}}).then((function(n){console.log(n),e({type:"UPDATE_NONCE",payload:t})})):console.warn("window.dappyRChain is undefined, cannot create token")}}}))((function(e){var t=Xe(Object(r.useState)(void 0),2),n=t[0],o=t[1],i=e.bags&&e.tokensData&&e.registryUri,c=void 0===e.tab;return console.log("erc1155Loaded",i),console.log("PROPS"),console.log(e),a.a.createElement("div",{className:"container"},a.a.createElement("h2",{className:"title is-2"},"ERC 1155 manager"),a.a.createElement("div",{className:"columns left-menu"},a.a.createElement("div",{className:"column is-one-quarter"},a.a.createElement("div",{className:"menu"},a.a.createElement("ul",{className:"menu-list"},a.a.createElement("li",null," ",a.a.createElement("a",{className:"",onClick:function(t){e.goDashboard()}},"Dashboard")),a.a.createElement("li",null," ",a.a.createElement("a",{className:"",onClick:function(t){e.goDeploy()}},"Deploy")),a.a.createElement("li",null," ",a.a.createElement("a",{className:"",onClick:function(t){e.goTransactions()}},"Transactions")),i?a.a.createElement(r.Fragment,null,a.a.createElement("li",null,a.a.createElement("a",{onClick:function(t){e.goPurchase()}},"Purchase token(s)")),a.a.createElement("li",null,a.a.createElement("a",{className:e.locked?"is-static":"",title:"Contract is locked, cannot create token",onClick:function(t){e.locked||e.goCreateToken()}},"Create token(s)")),a.a.createElement("li",null,a.a.createElement("a",{onClick:function(t){e.goSend()}},"Send token(s)")),a.a.createElement("li",null,a.a.createElement("a",{className:e.locked?"is-static":"",title:"Contract is locked, cannot update token data",onClick:function(t){e.locked||e.goUpdateTokenData()}},"Update token data")),a.a.createElement("li",null,a.a.createElement("a",{onClick:function(t){e.goUpdateBagData()}},"Update bag data")),a.a.createElement("li",null,a.a.createElement("a",{onClick:function(t){e.goSeeBagsData()}},"See bags data")),a.a.createElement("li",null,a.a.createElement("a",{className:e.locked?"is-static":"",title:"Contract is locked, cannot lock",onClick:function(t){e.locked||e.goSetLocked()}},"Lock contract"))):void 0))),a.a.createElement("div",{className:"column is-three-quarters"},c?a.a.createElement(C,{loadToken:function(t){o(t.registryUri),e.loadToken(t)},registryUri:n,loading:e.loading}):void 0,"transactions"===e.tab?a.a.createElement(Q,null):void 0,"creatingToken"===e.tab?a.a.createElement(de,{registryUri:n,nonce:e.nonce,createToken:e.createToken}):void 0,"sending"===e.tab?a.a.createElement(Oe,{registryUri:n,bags:e.bags,sendTokens:e.sendTokens}):void 0,"purchasing"===e.tab?a.a.createElement(V,{registryUri:n,purchaseToken:e.purchaseToken,bags:e.bags}):void 0,"updatingTokenData"===e.tab?a.a.createElement(re,{registryUri:n,updateTokenData:e.updateTokenData,nonce:e.nonce,tokensData:e.tokensData}):void 0,"seeingBagsData"===e.tab?a.a.createElement(Fe,{bagsData:e.bagsData}):void 0,"updatingBagData"===e.tab?a.a.createElement(We,{registryUri:n,updateBagData:e.updateBagData,bagsData:e.bagsData,bags:e.bags}):void 0,"locking"===e.tab?a.a.createElement(Ee,{registryUri:n,setLocked:e.setLocked,nonce:e.nonce}):void 0,"deploying"===e.tab?a.a.createElement(xe,{deploy:e.deploy}):void 0,i&&c?a.a.createElement(_,{tokensData:e.tokensData,bags:e.bags,publicKey:e.publicKey,locked:e.locked}):void 0)))})),tt=function(){return a.a.createElement(c.Provider,{store:d},a.a.createElement(et,null))};window.onload=function(){i.a.render(a.a.createElement(tt,null),document.getElementById("root"))},"undefined"!=typeof dappyRChain&&dappyRChain.fetch("dappy://REGISTRY_URI").then((function(e){var t=JSON.parse(e).expr[0],n=blockchainUtils.rhoValToJs(t);console.log(n),d.dispatch({type:"INIT",payload:{registryUri:n.registryUri.replace("rho:id:","")}}),i.a.render(a.a.createElement(tt,null),document.getElementById("root"))})).catch((function(e){console.error("Something went wrong when retreiving the files module object"),console.log(e)}))}]);