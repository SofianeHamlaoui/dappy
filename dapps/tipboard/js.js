!function(e){var n={};function t(r){if(n[r])return n[r].exports;var a=n[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var a in e)t.d(r,a,function(n){return e[n]}.bind(null,a));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=10)}([function(e,n){e.exports=React},function(e,n){e.exports=ReactDOM},function(e,n,t){const{erc1155Term:r}=t(3),{createTokensTerm:a}=t(4),{purchaseTokensTerm:o}=t(5),{sendTokensTerm:s}=t(6),{setLockedTerm:i}=t(7),{updateTokenDataTerm:u}=t(8),{updateBagDataTerm:c}=t(9);e.exports={erc1155Term:r,createTokensTerm:a,purchaseTokensTerm:o,sendTokensTerm:s,setLockedTerm:i,updateTokenDataTerm:u,updateBagDataTerm:c}},function(e,n){e.exports.erc1155Term=(e,n)=>`new \n  mainCh,\n  createCh,\n  purchaseCh,\n  sendCh,\n  entryCh,\n  entryUriCh,\n  setLockedCh,\n  updateTokenDataCh,\n  updateBagDataCh,\n  updateUriCh,\n  bags,\n  bagsData,\n  tokensData,\n  verifySignatureAndUpdateNonceCh,\n  justVerifySignatureCh,\n  insertArbitrary(\`rho:registry:insertArbitrary\`),\n  stdout(\`rho:io:stdout\`),\n  secpVerify(\`rho:crypto:secp256k1Verify\`),\n  blake2b256(\`rho:crypto:blake2b256Hash\`),\n  revAddress(\`rho:rev:address\`),\n  registryLookup(\`rho:registry:lookup\`)\nin {\n\n\n  /*\n    bags: {\n      [bagId: String (incremental id)]: {\n        publicKey: String (public key),\n        n: Nil \\/ String (token id),\n        price: Nil \\/ Int\n        quantity: Int\n      }\n    }\n  */\n  bags!({/*DEFAULT_BAGS*/}) |\n\n  /*\n    bagsData: {\n      [bagId: String (bag id)]: Any\n    }\n  */\n  bagsData!({/*DEFAULT_BAGS_DATA*/}) |\n\n  /*\n    tokensData: {\n      [n: Strig (token id)]: String (registry URI)\n    }\n  */\n  tokensData!({/*DEFAULT_TOKENS_DATA*/}) |\n\n  for (@(payload, returnCh) <= verifySignatureAndUpdateNonceCh) {\n    stdout!("verifySignatureAndUpdateNonceCh") |\n    new hashCh, verifySignatureCh in {\n      match payload {\n        { "newNonce": String, "signature": String} => {\n          for (@current <<- mainCh) {\n            blake2b256!(\n              current.get("nonce").toUtf8Bytes(),\n              *hashCh\n            ) |\n            for (@hash <- hashCh) {\n              secpVerify!(\n                hash,\n                payload.get("signature").hexToBytes(),\n                current.get("publicKey").hexToBytes(),\n                *verifySignatureCh\n              )\n            } |\n            for (@result <- verifySignatureCh) {\n              match result {\n                true => {\n                  @returnCh!(true) |\n                  for (@c <- mainCh) {\n                    mainCh!(c.set("nonce", payload.get("newNonce")))\n                  }\n                }\n                false => {\n                  @returnCh!("error: Invalid signature, could not perform operation")\n                }\n              }\n            }\n          }\n        }\n        _ => {\n          @returnCh!("error: invalid payload, structure should be { 'newNonce': String, 'signature': String }")\n        }\n      }\n    }\n  } |\n\n  for (@(publicKey, signature, nonce, returnCh) <= justVerifySignatureCh) {\n    stdout!("justVerifySignatureCh") |\n    new hashCh, verifySignatureCh in {\n      blake2b256!(\n        nonce.toUtf8Bytes(),\n        *hashCh\n      ) |\n      for (@hash <- hashCh) {\n        secpVerify!(\n          hash,\n          signature.hexToBytes(),\n          publicKey.hexToBytes(),\n          *verifySignatureCh\n        )\n      } |\n      for (@result <- verifySignatureCh) {\n        @returnCh!(result)\n      }\n    }\n  } |\n\n  contract setLockedCh(payload, return) = {\n    stdout!("setLockedCh") |\n\n    for (@current <<- mainCh) {\n      match current.get("locked") {\n        true => {\n          return!("error: contract is already locked")\n        }\n        false => {\n          new verifyCh in {\n            verifySignatureAndUpdateNonceCh!((\n              {\n                "newNonce": *payload.get("newNonce"),\n                "signature": *payload.get("signature"),\n              },\n              *verifyCh\n            )) |\n            for (@verified <- verifyCh) {\n              match verified {\n                true => {\n                  for (@c <- mainCh) {\n                    mainCh!(c.set("locked", true))\n                  } |\n                  return!(true)\n                }\n                err => {\n                  return!(err)\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  contract updateTokenDataCh(payload, return) = {\n    stdout!("updateTokenDataCh") |\n\n    for (@current <<- mainCh) {\n      match current.get("locked") {\n        true => {\n          return!("error: contract is locked, cannot update token data")\n        }\n        false => {\n          new verifyCh in {\n            verifySignatureAndUpdateNonceCh!((\n              {\n                "newNonce": *payload.get("newNonce"),\n                "signature": *payload.get("signature"),\n              },\n              *verifyCh\n            )) |\n            for (@verified <- verifyCh) {\n              match verified {\n                true => {\n                  for (@currentTokensData <- tokensData) {\n                    tokensData!(\n                      currentTokensData.set(*payload.get("n"), *payload.get("data"))\n                    )\n                  } |\n                  return!(true)\n                }\n                err => {\n                  return!(err)\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  contract updateBagDataCh(payload, return) = {\n    stdout!("updateBagDataCh") |\n    for (@currentBags <<- bags) {\n      match currentBags.get(*payload.get("bagId")) {\n        Nil => {\n          return!("error : token (bag ID) " ++ *payload.get("bagId") ++ " does not exist")\n        }\n        bag => {\n          new verifyCh in {\n            justVerifySignatureCh!((\n              bag.get("publicKey"),\n              *payload.get("signature"),\n              bag.get("nonce"),\n              *verifyCh\n            )) |\n            for (@verified <- verifyCh) {\n              match verified {\n                true => {\n                  for (@currentBagsData <- bagsData) {\n                    bagsData!(\n                      currentBagsData.set(*payload.get("bagId"), *payload.get("data"))\n                    ) |\n                    return!(true)\n                  }\n                }\n                err => {\n                  return!("error: Invalid signature, could not perform operation")\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  // add a token (1 or more)\n  contract createCh(payload, return) = {\n    stdout!("createCh") |\n\n    for (@current <<- mainCh) {\n      match current.get("locked") {\n        true => {\n          return!("error: contract is locked, cannot create token")\n        }\n        false => {\n          for (@currentBags <<- bags) {\n            new verifyCh in {\n              verifySignatureAndUpdateNonceCh!((\n                {\n                  "newNonce": *payload.get("newNonce"),\n                  "signature": *payload.get("signature"),\n                },\n                *verifyCh\n              )) |\n              for (@verified <- verifyCh) {\n                match verified {\n                  true => {\n                    match "\${n}" %% { "n": currentBags.size() } {\n                      bagId => {\n                        new nCh in {\n\n                          match *payload.get("n") {\n                            // token n already exists\n                            String => { nCh!(*payload.get("n")) }\n                            // token n does not exist, bag ID will be used as n\n                            _ => { nCh!(bagId) }\n                          } |\n\n                          for (@n <- nCh) {\n                            for (_ <- bags) {\n                              bags!(\n                                currentBags.set(bagId, {\n                                  "quantity": *payload.get("quantity"),\n                                  "publicKey": *payload.get("publicKey"),\n                                  "nonce": *payload.get("bagNonce"),\n                                  "n": n,\n                                  "price": *payload.get("price"),\n                                })\n                              ) \n                            } |\n\n                            match *payload.get("data") {\n                              Nil => {}\n                              data => {\n                                for (@currentTokensData <- tokensData) {\n                                  tokensData!(\n                                    currentTokensData.set(n, data)\n                                  )\n                                }\n                              }\n                            } |\n\n                            return!(true)\n                          }\n                        }\n                      }\n                    }\n                  }\n                  err => {\n                    return!(err)\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  // purchase token (1 or more)\n  contract purchaseCh(payload, return) = {\n    stdout!("purchaseCh") |\n    for (@currentBags <<- bags) {\n      match currentBags.get(*payload.get("bagId")) {\n        Nil => {\n          return!("error : token (bag ID) " ++ *payload.get("bagId") ++ " does not exist")\n        }\n        bag => {\n          match bag.get("quantity") - *payload.get("quantity") >= 0 {\n            false => {\n              return!("error : not enough tokens in bag (bag ID: " ++ *payload.get("bagId") ++ ") available")\n            }\n            true => {\n              new RevVaultCh, ownerRevAddressCh in {\n\n                registryLookup!(\`rho:rchain:revVault\`, *RevVaultCh) |\n                revAddress!("fromPublicKey", bag.get("publicKey").hexToBytes(), *ownerRevAddressCh) |\n\n                for (@(_, RevVault) <- RevVaultCh; @ownerRevAddress <- ownerRevAddressCh) {\n                  match (\n                    *payload.get("purseRevAddr"),\n                    ownerRevAddress,\n                    *payload.get("quantity") * bag.get("price")\n                  ) {\n                    (from, to, amount) => {\n                      new purseVaultCh in {\n                        @RevVault!("findOrCreate", from, *purseVaultCh) |\n                        for (@(true, purseVault) <- purseVaultCh) {\n\n                          new resultCh in {\n                            @purseVault!("transfer", to, amount, *payload.get("purseAuthKey"), *resultCh) |\n                            for (@result <- resultCh) {\n\n                              match result {\n                                (true, Nil) => {\n                                  match "\${bagId}" %% { "bagId": currentBags.size() } {\n                                    bagId => {\n                                      match *payload.get("data") {\n                                        Nil => {}\n                                        data => {\n                                          for (@currentBagsData <- bagsData) {\n                                            bagsData!(currentBagsData.set(bagId, data))\n                                          }\n                                        }\n                                      } |\n                                      for (_ <- bags) {\n                                        bags!(\n                                          // New bag ID for new token ownership\n                                          currentBags.set(bagId, {\n                                            "quantity": *payload.get("quantity"),\n                                            "publicKey": *payload.get("publicKey"),\n                                            "nonce": *payload.get("nonce"),\n                                            "n": bag.get("n"),\n                                            "price": Nil,\n                                          // Udate quantity in seller token ownership\n                                          }).set(\n                                            *payload.get("bagId"),\n                                            bag.set("quantity", bag.get("quantity") - *payload.get("quantity"))\n                                          )\n                                        ) |\n                                        return!(true)\n                                      }\n                                    }\n                                  }\n                                }\n                                _ => {\n                                  bags!(currentBags) |\n                                  return!("error : REV transfer went wrong " ++ result.nth(2))\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } |\n\n  contract sendCh(payload, return) = {\n    stdout!("sendCh") |\n    for (@currentBags <<- bags) {\n      match currentBags.get(*payload.get("bagId")) {\n        Nil => {\n          return!("error : token (bag ID) " ++ *payload.get("bagId") ++ " does not exist")\n        }\n        bag => {\n          match bag.get("quantity") - *payload.get("quantity") >= 0 {\n            true => {\n              new justVerifySignatureReturnCh in {\n                justVerifySignatureCh!((\n                  bag.get("publicKey"),\n                  *payload.get("signature"),\n                  bag.get("nonce"),\n                  *justVerifySignatureCh\n                )) |\n                for (@r <- justVerifySignatureCh) {\n                  stdout!(r) |\n                  match r {\n                    true => {\n                      match "\${bagId}" %% { "bagId": currentBags.size() } {\n                        bagId => {\n                          // Add bag data if found in payload\n                          match *payload.get("data") {\n                            Nil => {}\n                            data => {\n                              for (@currentBagsData <- bagsData) {\n                                bagsData!(currentBagsData.set(bagId, data))\n                              }\n                            }\n                          } |\n                          for (_ <- bags) {\n                            bags!(\n                              // New bag ID for new token ownership\n                              currentBags.set(bagId, {\n                                "quantity": *payload.get("quantity"),\n                                "publicKey": *payload.get("publicKey"),\n                                "nonce": *payload.get("bagNonce"),\n                                "n": bag.get("n"),\n                                "price": Nil,\n                              // Udate quantity in seller token ownership\n                              }).set(\n                                *payload.get("bagId"),\n                                bag.set(\n                                  "quantity", bag.get("quantity") - *payload.get("quantity")\n                                ).set(\n                                  "nonce",\n                                  *payload.get("bagNonce2")\n                                )\n                              )\n                            )\n                          } |\n                          return!(true)\n                        }\n                      }\n                    }\n                    false => {\n                      return!("error: Invalid signature, could not perform operation")\n                    }\n                  }\n                }\n              }\n            }\n            false => {\n              return!("error : not enough tokens in bag (bag ID) " ++ *payload.get("bagId") ++ " available")\n            }\n          }\n        }\n      }\n    }\n  } |\n  \n  contract entryCh(action, return) = {\n    match *action.get("type") {\n      // Read capabilities\n      "READ_BAGS" => {\n        for (currentBags <<- bags) {\n          return!(*currentBags)\n        }\n      }\n      "READ_BAGS_DATA" => {\n        for (currentBagsData <<- bagsData) {\n          return!(*currentBagsData)\n        }\n      }\n      "READ_TOKENS_DATA" => {\n        for (@currentTokensData <<- tokensData) {\n          return!(currentTokensData)\n        }\n      }\n      "READ" => {\n        for (current <<- mainCh) {\n          return!(*current)\n        }\n      }\n      // Admin capabilities (require a signature of the nonce)\n      "SET_LOCKED" => {\n        match *action.get("payload") {\n          { "locked": true, "signature": String, "newNonce": String } => {\n            setLockedCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'signature': String, 'newNonce': String, 'locked': Boolean }")\n          }\n        }\n      }\n      "UPDATE_TOKEN_DATA" => {\n        match *action.get("payload") {\n          { "signature": String, "newNonce": String, "n": String, "data": _ } => {\n            updateTokenDataCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'signature': String, 'newNonce': String, 'n': String, 'data': _ }")\n          }\n        }\n      }\n      "UPDATE_BAG_DATA" => {\n        match *action.get("payload") {\n          { "signature": String, "newNonce": String, "bagId": String, "data": _ } => {\n            updateBagDataCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'signature': String, 'newNonce': String, 'bagId': String, 'data': _ }")\n          }\n        }\n      }\n      "CREATE_TOKENS" => {\n        match *action.get("payload") {\n          {\n            "signature": String,\n            "newNonce": String,\n            "bagNonce": String,\n            "quantity": Int,\n            "publicKey": String,\n            "price": Nil \\/ Int,\n            "n": Nil \\/ String,\n            "data": _\n          } => {\n            createCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'signature': String, 'newNonce': String, 'bagNonce': String, 'quantity': Int, 'n': Nil or String, 'price': Nil or Int, 'publicKey': String, 'data': Any }")\n          }\n        }\n      }\n      // Anyone capabilities\n      "PURCHASE_TOKENS" => {\n        match *action.get("payload") {\n          { "quantity": Int, "bagId": String, "publicKey": String, "nonce": String, "data": _, "purseRevAddr": _, "purseAuthKey": _ } => {\n            purchaseCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'quantity': Int, 'bagId': String, 'publicKey': String, 'nonce': String, 'data': Any, 'purseRevAddr': String, 'purseAuthKey': AuthKey }")\n          }\n        }\n      }\n      "SEND_TOKENS" => {\n        match *action.get("payload") {\n          { "quantity": Int, "bagId": String, "publicKey": String, "signature": String, "bagNonce": String, "bagNonce2": String, "data": _, } => {\n            sendCh!(*action.get("payload"), *return)\n          }\n          _ => {\n            return!("error: invalid payload, structure should be { 'quantity': Int, 'bagId': Int, 'publicKey': String, 'signature': String, 'bagNonce': String, 'bagNonce2': String, 'data': Any }")\n          }\n        }\n      }\n      _ => {\n        return!("error: unknown action")\n      }\n    }\n  } |\n\n  insertArbitrary!(*entryCh, *entryUriCh) |\n\n  for (entryUri <- entryUriCh) {\n\n    mainCh!({\n      "registryUri": *entryUri,\n      "locked": false,\n      "publicKey": "${n}",\n      "nonce": "${e}",\n      "version": "0.3"\n    }) |\n    stdout!({\n      "registryUri": *entryUri,\n      "locked": false,\n      "publicKey": "${n}",\n      "nonce": "${e}",\n      "version": "0.3"\n    })\n\n    /*OUTPUT_CHANNEL*/\n  }\n}\n`},function(e,n){e.exports.createTokensTerm=(e,n,t,r,a,o,s,i,u)=>`new basket,\n  entryCh,\n  returnCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${e}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "CREATE_TOKENS",\n        "payload": {\n          // signature of the current nonce, with the private key of the owner (generateSignatureForNonce.js)\n          "signature": "${n}",\n          // new nonce, must be different and random (generateNonce.js)\n          "newNonce": "${t}",\n          // new nonce for the bag, must be random (generateNonce.js)\n          "bagNonce": "${r}",\n          // per token price, can be Nil if the token is not for sale\n          "price": ${s||"Nil"},\n          // The token you create can be a new one ("n" : Nil)\n          // or it can be linked to an existing token data (ex: "n": "0")\n          "n": ${"string"==typeof o?'"'+o+'"':"Nil"},\n          // quantity of tokens to create\n          "quantity": ${i},\n          // publicKey this set of tokens (depending on quantity) will belong to\n          "publicKey": "${a}", // used only if new token\n          // data is used only if new token ("n" : Nil)\n          "data": ${u?'"'+encodeURI(u)+'"':"Nil"}\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      String => { stdout!(*resp) }\n      true => { stdout!("success, token created") }\n    }\n  } |\n\n  basket!({ "status": "completed" })\n\n}\n`},function(e,n){e.exports.purchaseTokensTerm=(e,n,t,r,a,o,s)=>`\nnew\n  revVaultPurseCh,\n  priceCh,\n  quantityCh,\n  publicKeyCh,\n  nonceCh,\n  bagDataCh,\n  returnCh,\n  bagIdCh,\n  registryUriCh,\n  revAddressCh,\n  registryLookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`),\n  revAddress(\`rho:rev:address\`)\nin {\n\n  /*\n    The 5 following values must be filled with proper values\n  */ \n  // Registry URI of the ERC-1155 contract\n  registryUriCh!!(\`rho:id:${e}\`) |\n  // Unique ID of the token you want to purchase\n  bagIdCh!!("${n}") |\n  // Per token price, make sure it is accurate\n  priceCh!!(${t||"Nil"}) |\n  // Bag data: Any\n  bagDataCh!!(${r?'"'+encodeURI(r)+'"':"Nil"}) |\n  // Quantity you want to purchase, make sure enough are available\n  quantityCh!!(${a}) |\n  // Your public key\n  publicKeyCh!!("${o}") |\n  // A unique nonce to be changed on each operation\n  nonceCh!!("${s}") |\n\n  registryLookup!(\`rho:rchain:revVault\`, *revVaultPurseCh) |\n\n  /*\n    Create a vault/purse that is just used once (purse)\n  */\n  for(@(_, *RevVaultPurse) <- revVaultPurseCh) {\n    new unf, purseRevAddrCh, purseAuthKeyCh, vaultCh, revAddressCh in {\n      revAddress!("fromUnforgeable", *unf, *purseRevAddrCh) |\n      RevVaultPurse!("unforgeableAuthKey", *unf, *purseAuthKeyCh) |\n      for (@purseAuthKey <- purseAuthKeyCh; @purseRevAddr <- purseRevAddrCh) {\n\n        stdout!({"new purse rev addr": purseRevAddr, "purse authKey": purseAuthKey}) |\n\n        RevVaultPurse!("findOrCreate", purseRevAddr, *vaultCh) |\n\n        for (\n          @(true, *vault) <- vaultCh;\n          @publicKey <- publicKeyCh;\n          @nonce <- nonceCh;\n          @bagId <- bagIdCh;\n          @registryUri <- registryUriCh;\n          @price <- priceCh;\n          @bagData <- bagDataCh;\n          @quantity <- quantityCh\n        ) {\n\n          revAddress!("fromPublicKey", publicKey.hexToBytes(), *revAddressCh) |\n\n          new RevVaultCh in {\n\n            registryLookup!(\`rho:rchain:revVault\`, *RevVaultCh) |\n            for (@(_, RevVault) <- RevVaultCh; deployerRevAddress <- revAddressCh) {\n\n              stdout!(("3.transfer_funds.rho")) |\n\n              /*\n                Put price * quantity REV in the purse\n              */\n              match (\n                *deployerRevAddress,\n                purseRevAddr,\n                price * quantity\n              ) {\n                (from, to, amount) => {\n\n                  new vaultCh, revVaultkeyCh, deployerId(\`rho:rchain:deployerId\`) in {\n                    @RevVault!("findOrCreate", from, *vaultCh) |\n                    @RevVault!("deployerAuthKey", *deployerId, *revVaultkeyCh) |\n                    for (@(true, vault) <- vaultCh; key <- revVaultkeyCh) {\n\n                      stdout!(("Beginning transfer of ", amount, "REV from", from, "to", to)) |\n\n                      new resultCh, entryCh in {\n                        @vault!("transfer", to, amount, *key, *resultCh) |\n                        for (@result <- resultCh) {\n\n                          stdout!(("Finished transfer of ", amount, "REV to", to, "result was:", result)) |\n                          match result {\n                            (true, Nil) => {\n                              stdout!("yes") |\n                              registryLookup!(registryUri, *entryCh) |\n\n                              for(entry <- entryCh) {\n                                stdout!(("GET ENTRY", *entry)) |\n                                entry!(\n                                  {\n                                    "type": "PURCHASE_TOKENS",\n                                    "payload": {\n                                      "quantity": quantity,\n                                      "bagId": bagId,\n                                      "data": bagData,\n                                      "nonce": nonce,\n                                      "publicKey": publicKey,\n                                      "purseRevAddr": purseRevAddr,\n                                      "purseAuthKey": purseAuthKey\n                                    }\n                                  },\n                                  *returnCh\n                                ) |\n                                for (resp <- returnCh) {\n                                  match *resp {\n                                    String => { stdout!(*resp) }\n                                    true => { stdout!("success, purchase successful") }\n                                  }\n                                }\n                              }\n                            }\n                            _ => {\n                              stdout!(result) |\n                              stdout!("no")\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n`},function(e,n){e.exports.sendTokensTerm=(e,n,t,r,a,o,s,i)=>`new basket,\n  entryCh,\n  returnCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${e}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "SEND_TOKENS",\n        "payload": {\n          // signature of the current nonce, with the private key of the owner (generateSignatureForNonce.js)\n          "signature": "${n}",\n          // new nonce, must be different and random (generateNonce.js)\n          "bagNonce": "${t}",\n          // new nonce for the new bag\n          "bagNonce2": "${r}",\n          // bag ID (ex: "0")\n          "bagId": "${s}",\n          // quantity of tokens to send\n          "quantity": ${a},\n          // publicKey this send those tokens to (can be the same just split a bag)\n          "publicKey": "${o}",\n          // data (optional) to be attached to the new bag (in bagsData)\n          "data": ${i?'"'+encodeURI(i)+'"':"Nil"}\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      String => { stdout!(*resp) }\n      true => { stdout!("success, tokens sent") }\n    }\n  } |\n\n  basket!({ "status": "completed" })\n\n}\n`},function(e,n){e.exports.setLockedTerm=(e,n,t)=>`new basket,\n  entryCh,\n  returnCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${e}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "SET_LOCKED",\n        "payload": {\n          // signature of the current nonce, with the private key of the owner (generateSignatureForNonce.js)\n          "signature": "${t}",\n          // new nonce, must be different and random (generateNonce.js)\n          "newNonce": "${n}",\n          //you cannot unlock, this value must always be true\n          "locked": true\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      String => { stdout!(*resp) }\n      true => { stdout!("success, tokens locked") }\n    }\n  } |\n\n  basket!({ "status": "completed" })\n\n}\n`},function(e,n){e.exports.updateTokenDataTerm=(e,n,t,r)=>`new basket,\n  entryCh,\n  returnCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${e}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "UPDATE_TOKEN_DATA",\n        "payload": {\n          // signature of the current nonce, with the private key of the owner (generateSignatureForNonce.js)\n          "signature": "${signature}",\n          // new nonce, must be different and random (generateNonce.js)\n          "newNonce": "${n}",\n          // token ID you want to attach data to\n          "n": ${"string"==typeof t?'"'+t+'"':"Nil"},\n          // data is used only if new token ("n" : Nil)\n          "data": ${r?'"'+encodeURI(r)+'"':"Nil"}\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      String => { stdout!(*resp) }\n      true => { stdout!("success, token data updated") }\n    }\n  } |\n\n  basket!({ "status": "completed" })\n\n}\n`},function(e,n){e.exports.updateBagDataTerm=(e,n,t,r,a)=>`new basket,\n  entryCh,\n  returnCh,\n  lookup(\`rho:registry:lookup\`),\n  stdout(\`rho:io:stdout\`)\nin {\n\n  lookup!(\`rho:id:${e}\`, *entryCh) |\n\n  for(entry <- entryCh) {\n    entry!(\n      {\n        "type": "UPDATE_BAG_DATA",\n        "payload": {\n          // signature of the current nonce, with the private key of the owner (generateSignatureForNonce.js)\n          "signature": "${t}",\n          // new nonce, must be different and random (generateNonce.js)\n          "newNonce": "${n}",\n          // bag ID you want to attach data to\n          "bagId": "${r}",\n          // data is used only if new token ("n" : Nil)\n          "data": ${a?'"'+encodeURI(a)+'"':"Nil"}\n        }\n      },\n      *returnCh\n    )\n  } |\n\n  for (resp <- returnCh) {\n    match *resp {\n      String => { stdout!(*resp) }\n      true => { stdout!("success, bag data updated") }\n    }\n  } |\n\n  basket!({ "status": "completed" })\n\n}\n`},function(e,n,t){"use strict";t.r(n);var r=t(0),a=t.n(r),o=t(1),s=t.n(o),i=t(2),u=new Intl.NumberFormat("en-US",{maximumFractionDigits:8});function c(e){return(c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function l(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function d(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function p(e,n){return(p=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}function y(e){var n=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var t,r=f(e);if(n){var a=f(this).constructor;t=Reflect.construct(r,arguments,a)}else t=r.apply(this,arguments);return h(this,t)}}function h(e,n){return!n||"object"!==c(n)&&"function"!=typeof n?g(e):n}function g(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function f(e){return(f=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function b(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}var m=function(e){!function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&p(e,n)}(s,e);var n,t,r,o=y(s);function s(){var e;l(this,s);for(var n=arguments.length,t=new Array(n),r=0;r<n;r++)t[r]=arguments[r];return b(g(e=o.call.apply(o,[this].concat(t))),"state",{title:"Help me buy a sword !",description:"",price:1e8,quantity:1e3}),e}return n=s,(t=[{key:"render",value:function(){var e=this;return console.log(this.state),a.a.createElement("div",{className:"genesis-form form"},a.a.createElement("div",{id:"canvas"}),a.a.createElement("p",null,"Hi ! The tipping board has not been initialized yet. Choose a price per token, choose the quantity of tokens you want to create. And eventually title and description.",a.a.createElement("br",null),a.a.createElement("br",null),"By default one token equals one REV and 1000 tokens are created for the tip board. Fill free to change the values. Remember that 1 REV equals 100.000.000 dusts.",a.a.createElement("br",null),a.a.createElement("br",null)),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Title"),a.a.createElement("div",{className:"control"},a.a.createElement("input",{defaultValue:this.state.title,onInput:function(n){return e.setState({title:n.target.value})},className:"input",type:"text"}))),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Description"),a.a.createElement("div",{className:"control"},a.a.createElement("textarea",{className:"textarea",onInput:function(n){e.setState({description:n.target.value})},defaultValue:this.state.description}))),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Price for each token (dust)"),a.a.createElement("div",{className:"control"},a.a.createElement("input",{defaultValue:this.state.price,onInput:function(n){return e.setState({price:parseInt(n.target.value)})},className:"input",type:"number",min:1,step:1}))),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Quantity of tokens"),a.a.createElement("div",{className:"control"},a.a.createElement("input",{defaultValue:this.state.quantity,onChange:function(n){return e.setState({quantity:parseInt(n.target.value)})},className:"input",type:"number",min:1,step:1})),this.state&&this.state.price&&this.state.quantity&&this.state.title?a.a.createElement("p",null,"Total REV :"," ",u.format(this.state.price*this.state.quantity/1e8)," ",a.a.createElement("br",null),"Total dust (1 REV equals 100.000.000 dust):"," ",u.format(this.state.price*this.state.quantity)," "):void 0),a.a.createElement("div",{className:"field"},a.a.createElement("br",null),a.a.createElement("button",{className:"button is-light",disabled:!(this.state&&this.state.price&&this.state.quantity&&this.state.title),type:"button",onClick:function(n){e.state&&e.state.price&&e.state.quantity&&e.state.title&&e.props.onValuesChosen({price:e.state.price,quantity:e.state.quantity,title:encodeURI(e.state.title),description:encodeURI(e.state.description),nonce:e.props.nonce})}},"Save values and create tipping board !")))}}])&&d(n.prototype,t),r&&d(n,r),s}(a.a.Component);function v(e){return(v="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function C(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function k(e,n){return(k=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}function N(e){var n=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var t,r=E(e);if(n){var a=E(this).constructor;t=Reflect.construct(r,arguments,a)}else t=r.apply(this,arguments);return S(this,t)}}function S(e,n){return!n||"object"!==v(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function E(e){return(E=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var w=function(e){!function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&k(e,n)}(s,e);var n,t,r,o=N(s);function s(e){var n;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,s),(n=o.call(this,e)).state={quantity:0,name:""},n}return n=s,(t=[{key:"render",value:function(){var e=this;console.log(this.props);var n=Object.keys(this.props.bags).sort((function(e,n){return parseInt(n)-parseInt(e)})),t=this.props.values.sold[1]===this.props.values.sold[0];return a.a.createElement("div",{className:"tip-board"},a.a.createElement("h3",{className:"title is-3"},decodeURI(this.props.values.title)),this.props.values.description&&a.a.createElement("p",{className:"description"},decodeURI(this.props.values.description)),t&&a.a.createElement("h3",{className:"title is-4"},"All tokens are sold !"),a.a.createElement("p",null,this.props.values.sold[1]," out of ",this.props.values.sold[0]," tokens sold (",Math.round(100*this.props.values.sold[1]/this.props.values.sold[0]),"%)"),a.a.createElement("p",null,this.props.values.sold[0]-this.props.values.sold[1]," tokens are for sale at a price of"," ",u.format(this.props.values.price/1e8)," REV per token"),a.a.createElement("br",null),!t&&a.a.createElement("div",{className:"cell-form"},a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Quantity to purchase"),a.a.createElement("div",{className:"control"},a.a.createElement("input",{defaultValue:this.state.quantity,onInput:function(n){return e.setState({quantity:parseInt(n.target.value)})},className:"input",type:"number",min:1,step:1,max:this.props.max}))),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Name"),a.a.createElement("div",{className:"control"},a.a.createElement("input",{defaultValue:this.state.name,onInput:function(n){return e.setState({name:n.target.value})},className:"input",type:"text"}))),a.a.createElement("div",{className:"field"},a.a.createElement("label",{className:"label"},"Total price"),a.a.createElement("div",null,a.a.createElement("span",{className:"total-price"},a.a.createElement("b",null,u.format(this.state.quantity*this.props.values.price/1e8))," REV"),a.a.createElement("br",null),this.state.quantity*this.props.values.price<1e8&&a.a.createElement("span",{className:"total-price"},a.a.createElement("b",null,u.format(this.state.quantity*this.props.values.price))," dusts"))),a.a.createElement("div",{className:"field"},a.a.createElement("br",null),a.a.createElement("button",{className:"button is-light",disabled:!this.state.quantity,type:"button",onClick:function(n){e.state.quantity&&e.props.onPurchase({quantity:e.state.quantity,data:encodeURI(e.state.name)})}},"Tip !"))),a.a.createElement("div",{className:"tips"},a.a.createElement("p",null,n.length-1," contributions :"),n.map((function(n){if("0"!==n)return a.a.createElement("p",{key:n},a.a.createElement("b",{className:"name"},e.props.bagsData[n]?decodeURI(e.props.bagsData[n]):"Anonymous")," ",a.a.createElement("span",null,"tipped"),a.a.createElement("b",{className:"amount"},u.format(e.props.bags[n].quantity*e.props.values.price/1e8)," ","REV"))}))))}}])&&C(n.prototype,t),r&&C(n,r),s}(a.a.Component);function R(e){return(R="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function D(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function A(e,n){return(A=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}function T(e){var n=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var t,r=O(e);if(n){var a=O(this).constructor;t=Reflect.construct(r,arguments,a)}else t=r.apply(this,arguments);return I(this,t)}}function I(e,n){return!n||"object"!==R(n)&&"function"!=typeof n?_(e):n}function _(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function O(e){return(O=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function U(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}var q=function(e){!function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&A(e,n)}(s,e);var n,t,r,o=T(s);function s(e){var n;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,s),U(_(n=o.call(this,e)),"onValuesChosen",(function(e){if("undefined"!=typeof dappyRChain){var t='"0": { "publicKey": "'.concat("PUBLIC"+"_KEY".substr(0),'", "n": "0", "price": ').concat(e.price,', "quantity": ').concat(e.quantity," }"),r=blockchainUtils.generateNonce(),a=blockchainUtils.generateNonce(),o=Object(i.erc1155Term)(r,"PUBLIC"+"_KEY".substr(0)).replace("/*DEFAULT_BAGS*/",t).replace("/*OUTPUT_CHANNEL*/",'| erc1155OutputCh!({\n        "registryUri": *entryUri,\n      })'),s="\n   new entryCh, erc1155OutputCh, lookup(`rho:registry:lookup`), stdout(`rho:io:stdout`) in {\n\n     ".concat(o,' |\n\n     for (@output <- erc1155OutputCh) { \n       stdout!({\n         "quantity": ').concat(e.quantity,',\n         "price": ').concat(e.price,',\n         "title": "').concat(e.title,'",\n         "description": "').concat(e.description,'",\n         "erc1155RegistryUri": output.get("registryUri"),\n       }) |\n\n       lookup!(`rho:id:REGISTRY_URI`, *entryCh) |\n     \n       for(entry <- entryCh) {\n         entry!(\n           {\n             "type": "ADD",\n             "payload": {\n               "id": "values",\n               "file": {\n                "quantity": ').concat(e.quantity,',\n                "price": ').concat(e.price,',\n                "title": "').concat(e.title,'",\n                "description": "').concat(e.description,'",\n                 "erc1155RegistryUri": output.get("registryUri"),\n               },\n               "nonce": "').concat(a,'",\n               "signature": "SIGNATURE"\n             }\n           },\n           *stdout\n         )\n       }\n     }\n   }\n   ');dappyRChain.transaction({term:s,signatures:{SIGNATURE:e.nonce}}).then((function(e){n.setState({modal:"values-chosen"})}))}else console.warn("window.dappyRChain is undefined, cannot deploy ERC1155")})),U(_(n),"onPurchase",(function(e){dappyRChain.transaction({term:Object(i.purchaseTokensTerm)(n.props.erc1155RegistryUri.replace("rho:id:",""),"0",n.props.values.price,"".concat(e.data),e.quantity,"PUBLIC"+"_KEY".substr(0),blockchainUtils.generateNonce()),signatures:{}}).then((function(e){n.setState({modal:"purchase"})}))})),n.state={modal:void 0,bags:void 0,bagsData:void 0},n}return n=s,(t=[{key:"componentDidMount",value:function(){var e=this;this.props.bags&&(console.log("yes"),setInterval((function(){dappyRChain.exploreDeploys("dappy://explore-deploys",["new return,\n          entryCh,\n          lookup(`rho:registry:lookup`)\n          in {\n            lookup!(`".concat(e.props.values.erc1155RegistryUri,'`, *entryCh) |\n            for(entry <- entryCh) {\n              entry!(\n                {\n                  "type": "READ_BAGS",\n                },\n                *return\n              )\n            }\n          }'),"new return,\n          entryCh,\n          lookup(`rho:registry:lookup`)\n          in {\n            lookup!(`".concat(e.props.values.erc1155RegistryUri,'`, *entryCh) |\n            for(entry <- entryCh) {\n              entry!(\n                {\n                  "type": "READ_BAGS_DATA",\n                },\n                *return\n              )\n            }\n          }')]).then((function(n){var t=JSON.parse(n).results,r=blockchainUtils.rhoValToJs(JSON.parse(t[0].data).expr[0]),a=blockchainUtils.rhoValToJs(JSON.parse(t[1].data).expr[0]);e.setState({bags:r,bagsData:a})}))}),15e3))}},{key:"render",value:function(){var e=this;return"purchase"===this.state.modal?a.a.createElement("div",{className:"modal"},a.a.createElement("div",{className:"modal-background"}),a.a.createElement("div",{className:"modal-card"},a.a.createElement("header",{className:"modal-card-head"},a.a.createElement("p",{className:"modal-card-title"},"Purchase successful"),a.a.createElement("button",{onClick:function(){return e.setState({modal:void 0})},className:"delete","aria-label":"close"})),a.a.createElement("section",{className:"modal-card-body"},"Transaction was successfully sent. Wait few minutes, reload, and you should see your cell with the color you chose. Thank you for your participation."),a.a.createElement("footer",{className:"modal-card-foot"},a.a.createElement("button",{onClick:function(){return e.setState({modal:void 0})},class:"button"},"Ok")))):"genesis-form"===this.state.modal?a.a.createElement("div",{className:"modal"},a.a.createElement("div",{className:"modal-background"}),a.a.createElement("div",{className:"modal-card"},a.a.createElement("header",{className:"modal-card-head"},a.a.createElement("p",{className:"modal-card-title"},"Submit successful"),a.a.createElement("button",{onClick:function(){return e.setState({modal:void 0})},className:"delete","aria-label":"close"})),a.a.createElement("section",{className:"modal-card-body"},"Submit was successful, wait few minutes, reload, and the ERC-1155 contract should be initiated."),a.a.createElement("footer",{className:"modal-card-foot"},a.a.createElement("button",{onClick:function(){return e.setState({modal:void 0})},class:"button"},"Ok")))):this.props.values?a.a.createElement(w,{onPurchase:this.onPurchase,values:this.props.values,bagsData:this.state.bagsData||this.props.bagsData,max:this.props.bags[0].quantity,bags:this.state.bags||this.props.bags}):a.a.createElement(m,{onValuesChosen:this.onValuesChosen,nonce:this.props.nonce})}}])&&D(n.prototype,t),r&&D(n,r),s}(a.a.Component);function j(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function V(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?j(Object(t),!0).forEach((function(n){K(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):j(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function K(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}document.addEventListener("DOMContentLoaded",(function(){"undefined"!=typeof dappyRChain&&(window.location.href.includes("deltanetwork"),document.body.setAttribute("style",'background-image: url("dappy://deltanetwork/'.concat("bmadyako1aq9xoegiy5iayq4mqxykrts8h7i9od1ed5krkfo9s6i4m.index",'");')),dappyRChain.fetch("dappy://REGISTRY_URI").then((function(e){var n=JSON.parse(e).expr[0],t=blockchainUtils.rhoValToJs(n);console.log(t),t.files.values?dappyRChain.exploreDeploys("dappy://explore-deploys",["new return,\n                fileCh,\n                fileCh,\n                filesModuleCh,\n                lookup(`rho:registry:lookup`) in {\n                  lookup!(`".concat(t.files.values,"`, *fileCh) |\n                  for(file <- fileCh) {\n                    return!(*file)\n                  }\n              }")]).then((function(e){var n=JSON.parse(e).results,t=blockchainUtils.rhoValToJs(JSON.parse(n[0].data).expr[0]);console.log("files-module .values file retrieved with explore-deploy :"),console.log(t),dappyRChain.exploreDeploys("dappy://explore-deploys",["new return,\n                  entryCh,\n                  lookup(`rho:registry:lookup`)\n                  in {\n                    lookup!(`".concat(t.erc1155RegistryUri,'`, *entryCh) |\n                    for(entry <- entryCh) {\n                      entry!(\n                        {\n                          "type": "READ_BAGS",\n                        },\n                        *return\n                      )\n                    }\n                  }'),"new return,\n                  entryCh,\n                  lookup(`rho:registry:lookup`)\n                  in {\n                    lookup!(`".concat(t.erc1155RegistryUri,'`, *entryCh) |\n                    for(entry <- entryCh) {\n                      entry!(\n                        {\n                          "type": "READ_BAGS_DATA",\n                        },\n                        *return\n                      )\n                    }\n                  }')]).then((function(e){var n=JSON.parse(e).results,r=blockchainUtils.rhoValToJs(JSON.parse(n[0].data).expr[0]);console.log("ERC-1155 bags retrieved with explore-deploy :"),console.log(r);var o=0;Object.keys(r).forEach((function(e){"0"!==e&&(o+=r[e].quantity)}));var i=r[0].quantity+o,u=blockchainUtils.rhoValToJs(JSON.parse(n[1].data).expr[0]);console.log("ERC-1155 bagsData retrieved with explore-deploy :"),console.log(u),document.title=decodeURI(t.title),document.getElementById("root").setAttribute("class","loaded"),s.a.render(a.a.createElement(q,{values:V(V({},t),{},{sold:[i,o]}),bags:r,bagsData:u,erc1155RegistryUri:t.erc1155RegistryUri}),document.getElementById("root"))}))})):(document.getElementById("root").setAttribute("class","loaded"),s.a.render(a.a.createElement(q,{nonce:t.nonce,values:void 0,bags:void 0,bagsData:void 0}),document.getElementById("root")))})).catch((function(e){console.error("Something went wrong when retreiving the files module object"),console.log(e)})))}))}]);